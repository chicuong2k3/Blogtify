---
url: [/post/database-replication]
title: "Database Replication"
$attribute: PostMetadata(Id = 1, Title = "Database Replication", Category = "System Design", LastModified = "25-09-2025")
$layout: BlogContentLayout
---

# Database Replication là gì?

Hãy tưởng tượng bạn mới mở một quán cà phê trong thành phố. 
Ban đầu quán của bạn chỉ có một quầy pha chế duy nhất phục vụ khách hàng. 
Ban đầu thì ổn, nhưng khi khách đến đông, nhân viên sẽ không phục vụ kịp. 
Và tệ hơn là nếu quầy pha chế đó gặp sự cố thì cả quán coi như tê liệt.

Để tránh tình trạng này, bạn mở thêm vài quầy pha chế khác trong quán. 
Mỗi quầy đều có nguyên liệu giống nhau. Nhờ đó mà khách không còn phải chờ đợi lâu, 
quầy khác vẫn tiếp tục hoạt động bình thường.

Trong thế giới công nghệ cũng vậy, chúng ta tạo bản sao của dữ liệu trên các máy chủ cơ sở dữ liệu khác nhau. 
Cách làm này được gọi là Database Replication. Nó giúp hệ thống đạt được ba mục tiêu chính:
1. **Tính sẵn sàng cao (High Availability):** Nếu máy chủ chính gặp sự cố, 
máy chủ sao chép có thể ngay lập tức thay thế, đảm bảo hệ thống không ngừng hoạt động.
2. **Khả năng mở rộng hiệu năng (Performance Scalability):** Tải công việc đọc được phân tán 
trên nhiều máy chủ phụ, giảm áp lực cho máy chủ chính, giúp xử lý nhiều truy vấn hơn.
3. **An toàn dữ liệu (Data Safety):** Dữ liệu được sao lưu tự động trên nhiều máy chủ, 
giảm thiểu rủi ro mất mát dữ liệu.

<center>
<img src="/leader-follower.webp"  />
</center>

# Các mô hình Database Replication

## Leader-Follower Replication (còn gọi là master-slave replication)

Đây là mô hình phổ biến nhất. Một cơ sở dữ liệu được chỉ định làm Leader 
(còn gọi là Master/Primary), nơi duy nhất thực hiện các thao tác ghi (Write). 
Các cơ sở dữ liệu còn lại là Follower (còn gọi là Slave/Replica/Secondary), chỉ thực hiện 
thao tác đọc (Read).
Khi bạn cần thêm hoặc cập nhật thông tin, mọi thứ sẽ được thao tác trên leader trước. 
Sau đó, dữ liệu mới được đồng bộ sang các follower. 

Vậy làm sao để leader đồng bộ dữ liệu với follower?
Có hai cách phổ biến:

Statement-Based Replication (SBR): Leader gửi toàn bộ câu lệnh SQL cho các follower. 
Các follower sẽ thực thi lại các câu lệnh này. Cách này đơn giản nhưng có thể gặp vấn đề 
nếu các câu lệnh phụ thuộc vào thời gian hoặc môi trường cụ thể của leader.

Write-Ahead Log (WAL) Shipping: Đây là cơ chế được ưa chuộng hơn. Mọi thay đổi dữ liệu trên 
leader trước tiên được ghi vào một tệp log đặc biệt (gọi là Write-Ahead Log). 
Các follower liên tục sao chép và replay log này để áp dụng các thay đổi giống hệt leader. 
WAL đảm bảo tính nhất quán và toàn vẹn dữ liệu rất cao.

## Multi-Leader Replication

Hãy tưởng tượng bạn mở thêm một chi nhánh cà phê thứ hai ở một thành phố khác. 
Mỗi chi nhánh đều có quầy pha chế chính của riêng mình và họ cần đồng bộ công thức, 
số lượng nguyên liệu với nhau.

Trong mô hình này, có nhiều hơn một database đóng vai trò Leader. 
Mỗi leader đều có thể nhận cả thao tác ghi và đọc và dữ liệu sẽ được đồng bộ hai chiều giữa các leader với nhau.

Mô hình này có một vấn đề là xung đột ghi (write conflict). Nếu hai người dùng cùng sửa một 
dòng dữ liệu trên hai Leader khác nhau, hệ thống cần một cơ chế để giải quyết xung đột này.

Mô hình này phù hợp với các ứng dụng cần ghi ở nhiều trung tâm dữ liệu trên toàn cầu.


## Leaderless Replication

Hãy tưởng tượng một hệ thống mà khách hàng có thể đặt hàng ở bất kỳ quầy nào và 
nhân viên ở các quầy khác sẽ tự động cập nhật lại menu cho đồng bộ.

Trong mô hình này, không có khái niệm leader. Client có thể ghi hoặc đọc dữ liệu từ 
bất kỳ máy chủ nào trong cụm database (database cluster).

Khi ghi dữ liệu, client sẽ gửi yêu cầu ghi đến nhiều node cùng lúc. 
Hệ thống chỉ cần đảm bảo ghi thành công trên một số lượng node nhất định 
(như 3 trên tổng số 5 node) thì coi như thành công. Tương tự, khi đọc, client sẽ đọc 
từ nhiều node và lấy phiên bản dữ liệu mới nhất.

Các cơ sở dữ liệu NoSQL như Amazon DynamoDB và Apache Cassandra thường sử dụng mô hình này.
